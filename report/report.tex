\documentclass[a4paper,12pt]{article}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{array}
\usepackage{color} 
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage[font=small,labelfont=bf]{caption}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\usepackage{changepage}
\addto{\captionsenglish}{\renewcommand{\refname}{}}

\begin{document}

\title{%
  Group Project - Neo4j \\
  \large of Systems and Methods for Big
    and Unstructured Data Course \\(SMBUD)\\
    held by\\ Brambilla Marco\\ Tocchetti Andrea \\
  \vspace{5mm}
  \Large \textbf{Group 78}}
\author{Pisante Giuseppe\\
  \texttt{10696936}
  \and
  Raffaelli Martina\\
  \texttt{10709893}
}
\date{Academic year 2024/2025}
\maketitle
\begin{center}
  \includegraphics[width=4cm]{polilogo.png}\\
\end{center}
\newpage
\tableofcontents
\newpage
\section{Introduction}
\paragraph{} This project developes a comprehensive overview of an open source ecommerce dataset, through the use of the Neo4j technology, which is very well suited for this type of database.
\\
In particular, in order to fully exploit such technology, our study was developed using a relational database management system (RDBMS), which facilitates the querying of data to support the Marketing and Supply Chain division with key functions like product recommendations, customer segmentation, sales analysis, and inventory forecasting. 
The system allows for tracking of customer purchase history, order details, product categories, payment methods, and discounts, helping businesses optimize their operations and enhance the customer experience.

\newpage
\section{Assumptions}
\paragraph{} The project is based on the following assumptions:
\begin{itemize}[noitemsep]
   \item[-] Each customer has a unique ID, name, surname, email address, and date of birth.
   \item[-] Each product has a unique identifier, name, description, price, and category.
   \item[-] Each product can be associated with multiple categories.
   \item[-] Each customer can place multiple orders.
   \item[-] Each order can contain multiple products.
   \item[-] Each order has a unique ID, order date, total amount, and payment method.
   \item[-] Each product can have multiple variants (e.g., size, color).
   \item[-] Each product can have multiple reviews, where each review includes a rating and comments from a customer.
   \item[-] Each payment is associated with a unique transaction ID, payment method, and amount.
   \item[-] Each customer can leave a review for a product if and only if they have purchased it.
\end{itemize}

\clearpage
\section{Dataset}
\paragraph{}
	\begin{center}
 		\includegraphics[width = 15 cm]{polilogo.png}
		\captionof{figure}{E-R Diagram}
	\end{center}
  \subsection{Entities}
    \par Starting from the considerations previously exposed regarding the implementation hypotheses, we have drawn an ER diagram (\textbf{Figure 1}) which includes 8 different entities and 8 many-to-many relationships described below in the logical model: \par
    \begin{itemize}[noitemsep]
    \item[-]	\textbf{User}(\underline{user\_id}, Name, Email, Address, PhoneNumber, DateOfBirth)
    \item[-]	\textbf{Product}(\underline{product\_id}, ProductName, Description, Price, StockLevel, Category)
    \item[-]	\textbf{Order}(\underline{order\_id}, \underline{user\_id}, OrderDate, TotalAmount, PaymentMethod, ShippingAddress)
    \item[-]	\textbf{Order\_Item}(\underline{order\_id}, \underline{product\_id}, Quantity, UnitPrice)
    \item[-]	\textbf{Payment}(\underline{payment\_id}, \underline{order\_id}, PaymentDate, PaymentAmount, PaymentMethod)
    \item[-]	\textbf{Review}(\underline{review\_id}, \underline{user\_id}, \underline{product\_id}, Rating, Comment, ReviewDate)
    \item[-]	\textbf{Category}(\underline{category\_id}, CategoryName)
    \item[-]	\textbf{Distribution\_Center}(\underline{center\_id}, CenterName, Location)
    \end{itemize} \par

    The \textbf{User} entity represents the individuals who make purchases on the platform, storing essential information such as their personal details and contact information.

    The \textbf{Product} entity represents the items available for sale, including product details such as name, description, price, stock level, and category.

    The \textbf{Order} entity captures information related to a user’s order, such as the order date, total amount, payment method, and shipping address.

    The \textbf{Order\_Item} entity links products to specific orders, detailing the quantity of each product ordered and its unit price.

    The \textbf{Payment} entity records the payment details for each order, including the payment method, amount paid, and the date of payment.

    The \textbf{Review} entity stores customer feedback for purchased products, including ratings and comments, along with the review date.

    The \textbf{Category} entity defines the product categories, allowing for classification of products into different types (e.g., electronics, clothing).

    Finally, the \textbf{Distribution\_Center} entity represents the centers from which the products are shipped, capturing details such as center name and location.

    \subsection{Relationships}
    \begin{itemize}[noitemsep]
      
        \item[\textbf{User}] $(User)-[:PLACED]->(Order)$
        
        Relationship between a User and an Order, where a user can place multiple orders, and each order is linked to one user.
        
        \item[\textbf{Order}] $(Order)-[:CONTAINS]->(Order\_Item)$
        
        Relationship between an Order and the Order\_Item, where an order can contain multiple items, and each order item is linked to one order.
        
        \item[\textbf{Product}] $(Product)-[:PART\_OF]->(Order\_Item)$
        
        Relationship between a Product and the Order\_Item, where a product can appear in multiple order items, and each order item corresponds to a specific product.
        
        \item[\textbf{User}] $(User)-[:WRITES]->(Review)$
        
        Relationship between a User and a Review, where a user can write multiple reviews, and each review is written by one user.
        
        \item[\textbf{Product}] $(Product)-[:HAS\_REVIEW]->(Review)$
        
        Relationship between a Product and a Review, where a product can have multiple reviews, and each review is linked to one product.
        
        \item[\textbf{Order}] $(Order)-[:PAID\_BY]->(Payment)$
        
        Relationship between an Order and a Payment, where an order can have one or more payments, and each payment corresponds to one order.
        
        \item[\textbf{Order}] $(Order)-[:SHIPPED\_FROM]->(Distribution\_Center)$
        
        Relationship between an Order and a Distribution\_Center, where an order is processed by a single distribution center, and each distribution center can process multiple orders.
        
        \item[\textbf{Product}] $(Product)-[:BELONGS\_TO]->(Category)$
        
        Relationship between a Product and a Category, where a product can belong to one or more categories, and each category can contain multiple products.
        
    \end{itemize}
    


\subsection{Constraints:}
\par Based on the implementation assumptions and the entities defined above, we introduce several constraints to ensure the integrity and consistency of the data in the database. These constraints are applied to guarantee that each entity has a unique identifier and to prevent the creation of duplicate entries within the database.

\par Specifically, the following constraints are defined:

\begin{verbatim}
CREATE CONSTRAINT FOR (d:DistributionCenter) REQUIRE d.id IS UNIQUE 
CREATE CONSTRAINT FOR (u:User) REQUIRE u.id IS UNIQUE;
CREATE CONSTRAINT FOR (p:Product) REQUIRE p.id IS UNIQUE;
CREATE CONSTRAINT FOR (i:InventoryItem) REQUIRE i.id IS UNIQUE;
CREATE CONSTRAINT FOR (o:Order) REQUIRE o.order_id IS UNIQUE;
CREATE CONSTRAINT FOR (oi:OrderItem) REQUIRE oi.id IS UNIQUE;
\end{verbatim}

\par These constraints enforce uniqueness on the primary identifiers of the key entities:
\begin{itemize}[noitemsep]
    \item The \textbf{DistributionCenter} entity's ID (\texttt{d.id}) must be unique.
    \item The \textbf{User} entity's ID (\texttt{u.id}) must be unique.
    \item The \textbf{Product} entity's ID (\texttt{p.id}) must be unique.
    \item The \textbf{InventoryItem} entity's ID (\texttt{i.id}) must be unique.
    \item The \textbf{Order} entity's ID (\texttt{o.order\_id}) must be unique.
    \item The \textbf{OrderItem} entity's ID (\texttt{oi.id}) must be unique.
\end{itemize}

\par These constraints ensure that the database remains consistent, with no duplicate entries for the core entities.


\subsection{Data Import:}
\begin{verbatim}
  // Load Distribution Centers
LOAD CSV WITH HEADERS FROM "file:///distribution_centers.csv" AS row
WITH row WHERE row.id IS NOT NULL
MERGE (d:DistributionCenter {id: row.id})
ON CREATE SET d.name = row.name,
              d.latitude = toFloat(row.latitude),
              d.longitude = toFloat(row.longitude);

// Load Users
LOAD CSV WITH HEADERS FROM "file:///users.csv" AS row
WITH row WHERE row.id IS NOT NULL
MERGE (u:User {id: row.id})
ON CREATE SET u.first_name = row.first_name,
              u.last_name = row.last_name,
              u.email = row.email,
              u.age = toInteger(row.age),
              u.gender = row.gender,
              u.state = row.state,
              u.city = row.city,
              u.country = row.country,
              u.latitude = toFloat(row.latitude),
              u.longitude = toFloat(row.longitude),
              u.traffic_source = row.traffic_source,
              u.created_at = row.created_at
ON MATCH SET u.count = coalesce(u.count, 0) + 1;

// Load Products
LOAD CSV WITH HEADERS FROM "file:///products.csv" AS row
WITH row WHERE row.id IS NOT NULL
MERGE (p:Product {id: row.id})
ON CREATE SET p.name = row.name,
              p.brand = row.brand,
              p.category = row.category,
              p.cost = toFloat(row.cost),
              p.retail_price = toFloat(row.retail_price),
              p.department = row.department,
              p.sku = row.sku,
              p.distribution_center_id = row.distribution_center_id
ON MATCH SET p.count = coalesce(p.count, 0) + 1;

// Load Inventory Items
LOAD CSV WITH HEADERS FROM "file:///inventory_items.csv" AS row
WITH row WHERE row.id IS NOT NULL
MERGE (i:InventoryItem {id: row.id})
ON CREATE SET i.product_id = row.product_id,
              i.created_at = row.created_at,
              i.sold_at = row.sold_at,
              i.cost = toFloat(row.cost),
              i.product_category = row.product_category,
              i.product_name = row.product_name,
              i.product_brand = row.product_brand,
              i.product_retail_price = toFloat(row.product_retail_price),
              i.product_department = row.product_department,
              i.product_sku = row.product_sku,
              i.product_distribution_center_id = row.product_distribution_center_id
ON MATCH SET i.count = coalesce(i.count, 0) + 1;

// Load Orders
LOAD CSV WITH HEADERS FROM "file:///orders.csv" AS row
WITH row WHERE row.order_id IS NOT NULL
MERGE (o:Order {order_id: row.order_id})
ON CREATE SET o.user_id = row.user_id,
              o.status = row.status,
              o.created_at = row.created_at,
              o.shipped_at = row.shipped_at,
              o.delivered_at = row.delivered_at,
              o.returned_at = row.returned_at,
              o.num_of_item = toInteger(row.num_of_item),
              o.gender = row.gender
ON MATCH SET o.count = coalesce(o.count, 0) + 1;

// Load Order Items
LOAD CSV WITH HEADERS FROM "file:///order_items.csv" AS row
WITH row WHERE row.id IS NOT NULL
MERGE (oi:OrderItem {id: row.id})
ON CREATE SET oi.order_id = row.order_id,
               oi.user_id = row.user_id,
               oi.product_id = row.product_id,
               oi.inventory_item_id = row.inventory_item_id,
               oi.status = row.status,
               oi.created_at = row.created_at,
               oi.shipped_at = row.shipped_at,
               oi.delivered_at = row.delivered_at,
               oi.returned_at = row.returned_at
ON MATCH SET oi.count = coalesce(oi.count, 0) + 1;
\end{verbatim}

\section{Cypher Queries}
In order to provide the Marketing and Logistics departments with the necessary insights, we have developed a series of Cypher queries that address various aspects of the business operations.
\subsection{Market Analysis for Marketing Department}
This section of the Cypher Queries aims at providing the Marketing department with insights on the share within the market by providing the number of orders in the Countries in which the Company operates.
In particular, this is done by providing an overview on the total orders per country, the revenue per country, a demographic overview per country and an analysis of the most present brands within a specific 
category, which in this study was chosen as the category with the most orders for further relevance.
In particular, a very useful instrument for the Marketing department is the segmentation of the user base, which allows to divide the users into different categories based on their frequency and spending habits.
\subsubsection{Total orders by Country}
This queries the database to determine the total number of orders placed by users in each country, providing insights into the distribution of orders across different regions.
\begin{verbatim}
  MATCH (u:User)-[:PLACES]->(o:Order)
  RETURN u.country AS country, COUNT(o) AS total_orders
  ORDER BY total_orders DESC;
\end{verbatim}
\begin{table}[h!]
  \centering
  \caption{Total Orders by Country}
  \label{tab:total_orders}
  \begin{tabular}{l r}
      \toprule
      \textbf{Country} & \textbf{Total Orders} \\
      \midrule
      China           & 42,986 \\
      United States   & 28,099 \\
      Brasil          & 18,262 \\
      South Korea     & 6,620  \\
      France          & 5,968  \\
      United Kingdom  & 5,673  \\
      Germany         & 5,286  \\
      Spain           & 4,965  \\
      Japan           & 2,945  \\
      Australia       & 2,630  \\
      Belgium         & 1,441  \\
      Poland          & 325    \\
      Colombia        & 19     \\
      España          & 4      \\
      Austria         & 2      \\
      Deutschland     & 1      \\
      \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Revenue per Country}
This query calculates the total revenue generated by orders placed by users in each country, providing insights into the revenue distribution across different regions.
\begin{verbatim}
  MATCH (u:User)-[:PLACES]->(o:Order)-[:CONTAINS]->(oi:OrderItem)
  MATCH (oi)-[:REFERS_TO]->(p:Product)
  RETURN u.country AS country, SUM(p.cost) AS total_revenue
  ORDER BY total_revenue DESC;
\end{verbatim}
\begin{table}[h!]
  \centering
  \caption{Total Revenue by Country}
  \label{tab:total_revenue}
  \begin{tabular}{l r}
      \toprule
      \textbf{Country} & \textbf{Total Revenue} \\
      \midrule
      China           & 1,800,865.85 \\
      United States   & 1,162,263.11 \\
      Brasil          & 747,519.90 \\
      South Korea     & 278,958.29 \\
      France          & 243,130.02 \\
      United Kingdom  & 242,263.07 \\
      Germany         & 217,875.61 \\
      Spain           & 210,278.08 \\
      Japan           & 124,807.02 \\
      Australia       & 106,009.74 \\
      Belgium         & 60,226.06 \\
      Poland          & 13,386.90 \\
      Colombia        & 572.51 \\
      España          & 91.87 \\
      Deutschland     & 65.70 \\
      Austria         & 41.51 \\
      \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Demographic Overview}
This query provides an overview of the user demographics, including the total number of users, the average age, and the country they belong to.
\begin{verbatim}
  MATCH (u:User)
  RETURN u.country AS country, 
       COUNT(u) AS total_users,
       AVG(u.age) AS average_age
  ORDER BY total_users DESC;
\end{verbatim}
\begin{table}[h!]
  \centering
  \caption{Total Users and Average Age by Country}
  \label{tab:Average_age}
  \begin{tabular}{l r r}
      \toprule
      \textbf{Country} & \textbf{Total Orders} & \textbf{Average Value} \\
      \midrule
      China           & 34,150  & 40.89 \\
      United States   & 22,522  & 41.21 \\
      Brasil          & 14,507  & 41.19 \\
      South Korea     & 5,316   & 41.25 \\
      France          & 4,700   & 41.57 \\
      United Kingdom  & 4,561   & 41.05 \\
      Germany         & 4,155   & 40.86 \\
      Spain           & 4,062   & 41.01 \\
      Japan           & 2,438   & 40.89 \\
      Australia       & 2,146   & 40.98 \\
      Belgium         & 1,185   & 39.54 \\
      Poland          & 235     & 42.43 \\
      Colombia        & 17      & 34.88 \\
      Deutschland     & 2       & 40.50 \\
      España          & 2       & 38.50 \\
      Austria         & 2       & 50.00 \\
      \bottomrule
  \end{tabular}
\end{table}

  \subsubsection{Categories with the most orders}
  This query identifies the top three product categories with the highest number of orders, providing insights into the most popular product categories among customers.
  \begin{verbatim}  
    MATCH (oi:OrderItem)-[:REFERS_TO]->(p:Product)
    RETURN p.product_category AS category, COUNT(oi) AS total_orders
    ORDER BY total_orders DESC
    LIMIT 3;
  \end{verbatim}
  \begin{table}[h!]
    \centering
    \caption{Categories with the most orders}
    \label{tab:total_orders_category}
    \begin{tabular}{l r}
        \toprule
        \textbf{Category} & \textbf{Total Orders} \\
        \midrule
        Intimates     & 13,474 \\
        Jeans         & 12,698 \\
        Tops \& Tees  & 11,925 \\
        \bottomrule
    \end{tabular}
\end{table}

   \subsubsection{Most present brands within the intimates category}
    This query identifies the top five brands with the highest number of sales within the intimates category, providing insights into the most popular brands in this product category.
   \begin{verbatim}
    MATCH (oi:OrderItem)-[:REFERS_TO]->(p:Product)
    WHERE p.category = "Intimates"

    RETURN p.brand AS brand, 
          COUNT(oi) AS total_sales
    ORDER BY total_sales DESC
    LIMIT 5;
    \end{verbatim}

    \begin{table}[h!]
      \centering
      \caption{Most present brands within the intimates categor}
      \label{tab:total_sales}
      \begin{tabular}{l r}
          \toprule
          \textbf{Brand}     & \textbf{Total Sales} \\
          \midrule
          Bali           & 405 \\
          Maidenform    & 383 \\
          Hanes         & 364 \\
          Laura         & 342 \\
          Vanity Fair   & 306 \\
          \bottomrule
      \end{tabular}
  \end{table}

  \subsubsection{Most present brands within the intimates category per country}
  This query identifies the top-selling brand within the intimates category for each country, providing insights into the brand preferences of customers in different regions.
  \begin{verbatim}
    MATCH (u:User)-[:ORDERED]->(oi:OrderItem)-[:REFERS_TO]->(p:Product)
    WHERE p.category = "Intimates"
    WITH u.country AS country, 
        p.brand AS brand, 
        COUNT(oi) AS total_sales
    ORDER BY country, total_sales DESC
    WITH country, COLLECT({brand: brand, total_sales: total_sales}) AS brand_sales
    RETURN country, 
          brand_sales[0].brand AS top_brand, 
          brand_sales[0].total_sales AS top_sales
    ORDER BY country;
    \end{verbatim}
    \begin{table}[h!]
      \centering
      \caption{Total Orders and Average Value by Country}
      \label{tab:orders_and_average}
      \begin{tabular}{l r r}
          \toprule
          \textbf{Country} & \textbf{Total Orders} & \textbf{Average Value} \\
          \midrule
          China           & 34,150  & 40.89 \\
          United States   & 22,522  & 41.21 \\
          Brasil          & 14,507  & 41.19 \\
          South Korea     & 5,316   & 41.25 \\
          France          & 4,700   & 41.57 \\
          United Kingdom  & 4,561   & 41.05 \\
          Germany         & 4,155   & 40.86 \\
          Spain           & 4,062   & 41.01 \\
          Japan           & 2,438   & 40.89 \\
          Australia       & 2,146   & 40.98 \\
          Belgium         & 1,185   & 39.54 \\
          Poland          & 235     & 42.43 \\
          Colombia        & 17      & 34.88 \\
          Deutschland     & 2       & 40.50 \\
          España          & 2       & 38.50 \\
          Austria         & 2       & 50.00 \\
          \bottomrule
      \end{tabular}
  \end{table}

  \subsubsection{Top traffic source per Country}
  This query identifies the top traffic source for users in each country, providing insights into the most effective marketing channels for customer acquisition.
  \begin{verbatim}
    MATCH (u:User)
    WHERE u.traffic_source IS NOT NULL
    WITH u.country AS country, u.traffic_source AS traffic_source, COUNT(*) AS amount
    WITH country, traffic_source, amount
    ORDER BY country, amount DESC
    WITH country, COLLECT({traffic_source: traffic_source, amount: amount}) AS traffic_data
    RETURN country, traffic_data[0].traffic_source AS top_traffic_source, traffic_data[0].amount AS max_amount
    ORDER BY country;
  \end{verbatim}  

  \begin{table}[h!]
    \centering
    \caption{Search Data by Country}
    \label{tab:search_data}
    \begin{tabular}{l l r}
        \toprule
        \textbf{Country} & \textbf{Platform} & \textbf{Count} \\
        \midrule
        Australia       & Search & 1518 \\
        Austria         & Facebook & 1 \\
        Belgium         & Search & 856 \\
        Brasil          & Search & 10147 \\
        China           & Search & 23876 \\
        Colombia        & Search & 9 \\
        Deutschland     & Search & 1 \\
        España          & Search & 2 \\
        France          & Search & 3310 \\
        Germany         & Search & 2921 \\
        Japan           & Search & 1746 \\
        Poland          & Search & 177 \\
        South Korea     & Search & 3701 \\
        Spain           & Search & 2845 \\
        United Kingdom  & Search & 3197 \\
        United States   & Search & 15768 \\
        \bottomrule
    \end{tabular}
\end{table}

  \subsubsection{Segmentation of User base}
  This query segments users based on their frequency and spending habits into four categories: High Frequency, High Spending; High Frequency, Low Spending; Low Frequency, High Spending; Low Frequency, Low Spending.
  \begin{verbatim}
    MATCH (u:User)-[:PLACES]->(o:Order)-[:CONTAINS]->(oi:OrderItem)-[:REFERS_TO]->(p:Product)
    WITH u, o, SUM(p.cost) AS total_price, COUNT(oi) AS order_count
    WITH u, total_price, order_count,
        CASE 
            WHEN total_price > 30 AND order_count > 3 THEN 'High Frequency, High Spending'
            WHEN total_price <= 30 AND order_count > 3 THEN 'High Frequency, Low Spending'
            WHEN total_price > 30 AND order_count <= 3 THEN 'Low Frequency, High Spending'
            ELSE 'Low Frequency, Low Spending'
        END AS segment
    RETURN segment, COUNT(u) AS user_count
    ORDER BY user_count DESC;
  \end{verbatim}  

  \begin{table}[h!]
    \centering
    \caption{Customer Segments by Frequency and Spending}
    \label{tab:customer_segments}
    \begin{tabular}{l r}
        \toprule
        \textbf{Segment} & \textbf{Count} \\
        \midrule
        Low Frequency, Low Spending  & 67152 \\
        Low Frequency, High Spending & 51702 \\
        High Frequency, High Spending & 6340 \\
        High Frequency, Low Spending & 32 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsubsection{Best and Worst Selling Product Categories by Season}
This query analyzes the purchasing patterns of product categories by season. For each season (Winter, Spring, Summer, and Fall),
it identifies the most frequently purchased category (best-selling) and the least frequently purchased category (worst-selling).
The results are based on the frequency of orders containing products from each category, with the categories being ranked by the total number of purchases in each season.
\begin{verbatim}
    MATCH (u:User)-[:PLACES]->(o:Order)-[:CONTAINS]->(oi:OrderItem)-[:REFERS_TO]->(p:Product)
    WITH p.category AS product_category, 
      CASE 
          WHEN toInteger(substring(o.created_at, 5, 2)) IN [12, 1, 2] THEN 'Winter'
          WHEN toInteger(substring(o.created_at, 5, 2)) IN [3, 4, 5] THEN 'Spring'
          WHEN toInteger(substring(o.created_at, 5, 2)) IN [6, 7, 8] THEN 'Summer'
          WHEN toInteger(substring(o.created_at, 5, 2)) IN [9, 10, 11] THEN 'Fall'
      END AS season, 
      COUNT(*) AS frequency
    WITH season, product_category, frequency
    ORDER BY season, frequency DESC
    WITH season, collect({category: product_category, freq: frequency}) AS categories
    RETURN season, categories[0] AS top_category, categories[-1] AS worst_category;
\end{verbatim}  

\begin{table}[h!]
  \centering
  \caption{Customer Segments by Frequency and Spending}
  \label{tab:customer_segments}
  \begin{tabular}{l l l}
      \toprule
      \textbf{Season} & \textbf{TopCategory} & \textbf{WorstCategory}\\
      \midrule
      "Fall" & {"category": "Intimates","freq": 3854} & {"category": "Clothing Sets","freq": 63} \\
      "Spring" & {"category": "Intimates", "freq": 2543} & {"category": "Clothing Sets", "freq": 36} \\
      "Summer" & {"category": "Intimates", "freq": 3078} & {"category": "Clothing Sets", "freq": 52} \\
      "Winter" & {"category": "Intimates", "freq": 3999} & {"category": "Clothing Sets", "freq": 62} \\
      \bottomrule
  \end{tabular}
\end{table}
The result we obtain may seem strange since in all the seasons the top and worst categories are the same, so we checked the correctness of the result with the following query, which computes the frequency of every category in each season:
\begin{verbatim}
MATCH (u:User)-[:PLACES]->(o:Order)-[:CONTAINS]->(oi:OrderItem)-[:REFERS_TO]->(p:Product)
WITH p.category AS product_category, 
     CASE 
         WHEN toInteger(substring(o.created_at, 5, 2)) IN [12, 1, 2] THEN 'Winter'
         WHEN toInteger(substring(o.created_at, 5, 2)) IN [3, 4, 5] THEN 'Spring'
         WHEN toInteger(substring(o.created_at, 5, 2)) IN [6, 7, 8] THEN 'Summer'
         WHEN toInteger(substring(o.created_at, 5, 2)) IN [9, 10, 11] THEN 'Fall'
     END AS season, 
     COUNT(*) AS frequency
RETURN product_category, season, frequency
ORDER BY frequency DESC;
\end{verbatim}

\subsubsection{Age-based Segmentation}
This query segments users based on their age into the following groups: 18-24, 25-34, 35-44, 45-54, 55-64, and 65+.
It then calculates the total number of users, total amount spent, and average amount spent per user for each age group and returns the results in ascending order of age group.
Analysing the results we can see that the values of the average amount spent per user are quite similar across all age groups, so we should rely on the total amount spent to identify the most valuable segments, which is going to be the 65+ group.
\begin{verbatim}
  MATCH (u:User)-[:PLACES]->(o:Order)-[:CONTAINS]->(oi:OrderItem)-[:REFERS_TO]->(p:Product)
  WITH u, 
      CASE 
          WHEN u.age >= 18 AND u.age <= 24 THEN '18-24'
          WHEN u.age >= 25 AND u.age <= 34 THEN '25-34'
          WHEN u.age >= 35 AND u.age <= 44 THEN '35-44'
          WHEN u.age >= 45 AND u.age <= 54 THEN '45-54'
          WHEN u.age >= 55 AND u.age <= 64 THEN '55-64'
          ELSE '65+'
      END AS age_group, 
      p.cost AS product_price
  WITH age_group, COUNT(DISTINCT u) AS user_count, SUM(product_price) AS total_spent
  WITH age_group, user_count, total_spent, 
      CASE 
          WHEN user_count > 0 THEN total_spent / user_count
          ELSE 0
      END AS avg_spent_per_user
  RETURN age_group, user_count, total_spent, avg_spent_per_user
  ORDER BY age_group;
\end{verbatim}

\begin{table}[h!]
  \centering
  \caption{Customer Segmentation}
  \label{tab:processing_data}
  \begin{tabular}{l l l l}
      \toprule
      \textbf{AgeGroup} & \textbf{UserCount} & \textbf{TotalSpent} & \textbf{AvgSpentPerUser}\\
      \midrule
      "18-24" & 9505 & 616204.0050523246 & 64.82945871144919 \\
      "45-54" & 13507 & 876656.9810595925 & 64.903900278344 \\
      "35-44" & 13654 & 879153.417123852 & 64.38797547413593 \\
      "25-34" & 13486 & 882255.4374447308 & 65.42009768980652 \\
      "55-64" & 13630 & 896658.8652415214 & 65.78568343664867 \\
      "65+" & 16262 & 1057426.51384831 & 65.02438284640942 \\
      \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Top Product Categories Purchased by Gender in the Selected Segment}
This query identifies the top 5 product categories with the highest purchase frequency for each gender (male and female) for the users belonging to the 65+ age group.
This analysis can provide insights into the preferences and behaviors of the older demographic, helping tailor marketing strategies to better target this segment.

\begin{verbatim}
  MATCH (u:User)-[:PLACES]->(o:Order)-[:CONTAINS]->(oi:OrderItem)-[:REFERS_TO]->(p:Product)
  WHERE u.age >= 65
  WITH u.gender AS gender, p.category AS product_category, COUNT(*) AS frequency
  // Raggruppa per genere e categoria di prodotto
  WITH gender, product_category, frequency
  ORDER BY frequency DESC
  // Limita il numero di risultati per ciascun gruppo
  WITH gender, COLLECT({category: product_category, frequency: frequency}) AS categories
  WITH gender, categories[0..5] AS top_categories
  UNWIND top_categories AS top_category
  RETURN gender, top_category.category AS product_category, top_category.frequency AS frequency
  ORDER BY gender, frequency DESC;
\end{verbatim}

\begin{table}[h!]
  \centering
  \caption{Top 5 Product Categories per Gender}
  \label{tab:processing_data}
  \begin{tabular}{l l l}
      \toprule
      \textbf{Gender} & \textbf{ProductCategory} & \textbf{Frequency} \\
      \midrule
      "F"	& "Intimates" &	1349\\
      "F" & "Swim" & 544 \\
      "F" & "Dresses" & 539 \\
      "F" & "Fashion Hoodies \& Sweatshirts" & 536 \\
      "F" & "Maternity" & 524 \\
      "M" & "Underwear" & 786 \\
      "M" & "Tops \& Tees" & 773 \\
      "M" & "Jeans" & 771 \\
      "M" & "Pants" & 726 \\
      "M" & "Fashion Hoodies \& Sweatshirts" & 692 \\
      \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Top 10 Users by Orders Number and Total Spending}
This query identifies the top 10 users who placed the highest number of orders. It also calculates the total amount spent by each user by summing the costs of the products in their orders. The results are sorted first by the number of orders in descending order, and in case of ties, by total spending in descending order. For each user, the query returns their user ID, email, number of orders, and total spending, offering a comprehensive overview of the platform's most valuable customers.
The idea behind it could be to increase fidelization by offering them special discounts or promotions.
\begin{verbatim}
  // Step 1: Number of orders per user
  MATCH (u:User)-[:PLACES]->(o:Order)
  WITH u, COUNT(o) AS num_orders

  // Step 2: Total spent by user
  MATCH (u)-[:PLACES]->(:Order)-[:CONTAINS]->(oi:OrderItem)-[:REFERS_TO]->(p:Product)
  WITH u.id AS user_id, 
      u.email AS email, 
      num_orders, 
      SUM(p.cost) AS total_spent

  // Step 3: Order by number of orders and total spent
  ORDER BY num_orders DESC, total_spent DESC
  LIMIT 10
  RETURN user_id, email, num_orders, total_spent;
\end{verbatim}

\subsubsection{Users without Orders}
This query retrieves the user IDs and email addresses of all users who have not placed any orders. The idea behind it is that the marketing department could use the user's email to encourage them to make a purchase by sending them targeted promotions or discounts.
\begin{verbatim}
  MATCH (u:User)
  WHERE NOT EXISTS {
      MATCH (u)-[:PLACES]->(:Order)
  }
  RETURN u.id AS user_id, u.email AS email
  ORDER BY u.id
  LIMIT 10;
\end{verbatim}


\subsection{Logistic Analysis for Logistics Department}
This section of the Cypher Queries aims at providing the Logistics department with insights on the real-time tracking of the orders and all the possible information related to tuser in order to make the delivery as smooth as possible.
In particular, this is done by evaluating the closest distribution center for a specific user, the status of the order, the update of the history of the orders of user and to check if the user has some order pending, in which case the items can be sent together. 

\subsubsection{Closest Distribution Center}
This query calculates the distance between a specific user and all distribution centers in the database, and returns the name of the closest distribution center along with the distance in meters.
\begin{verbatim}
  MATCH (u:User)-[:PERFORM_EVENT]->(h:History)
  WHERE u.id = "100"
  MATCH (d:DistributionCenter)
  WHERE d.latitude IS NOT NULL AND d.longitude IS NOT NULL
  WITH u, d, 
      point({latitude: u.latitude, longitude: u.longitude}) AS user_location, 
      point({latitude: d.latitude, longitude: d.longitude}) AS distribution_center_location
  WITH u, d, user_location, distribution_center_location, 
      point.distance(user_location, distribution_center_location) AS distance
  ORDER BY distance
  LIMIT 1
  RETURN d.name, distance;
\end{verbatim}

\begin{table}[h!]
  \centering
  \caption{Data for Los Angeles CA}
  \label{tab:los_angeles_data}
  \begin{tabular}{l r}
      \toprule
      \textbf{Location} & \textbf{Value} \\
      \midrule
      Los Angeles CA & 10539304.46257035 \\
      \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Order History}
In order to provide our logistic department with the most updated information, we have to provide them with the history of the orders of a specific user.
In particular, we have to fill the history node with the latest information. In order to do that, we first add the new order to order, and then we add the new order to the history of the user.
\begin{verbatim}
  // Add the new order to the order node
    MATCH (u:User)
    WHERE u.id="100"
    WITH u
    MATCH (o:Order)
    WITH u, MAX(o.order_id) AS max_order_id
    CREATE (newOrder:Order { 
        order_id: toString(200000), 
        status: "Processing",
        gender: u.gender,
        created_at: date(),
        returned_at: null,
        shipped_at: null,
        delivered_at: null,
        num_of_item: 3
    })
    MERGE (u)-[:PLACES]->(newOrder);
\end{verbatim}
\begin{verbatim}
  // Add the new order to the history of the user
    MATCH (u:User)-[:PERFORM_EVENT]->(h:History)
    WHERE u.id = "100"
    MATCH (o:Order)
    WHERE o.order_id ="300000"
    SET h.orders_list = coalesce(h.orders_list, []) + "300000",
        h.number_of_orders = h.number_of_orders +1
    MERGE (u)-[:USER_HAS_ORDER]->(o)
\end{verbatim}

\subsubsection{Number of orders pending}
This query retrieves the number of orders that are currently pending for a specific user. This information can be used by the logistics department to prioritize the processing and delivery of orders for users with multiple pending orders.
\begin{verbatim}
  MATCH (u:User {id: <user_id>})-[:PLACES]->(o:Order)
  WITH u, count(o) AS total_orders
  WHERE total_orders = 10
  RETURN u.id AS user_id, total_orders
\end{verbatim}

\subsubsection{Management of multiple orders}
This query retrieves the order IDs of all orders that are currently pending for a specific user. This information can be used by the logistics department to group multiple orders together for delivery, reducing the number of shipments and improving efficiency.
\begin{verbatim}
  MATCH (u:User)-[:PLACES]->(o:Order)
  WHERE u.id="100" AND o.status = 'Processing'  
  RETURN o.order_id, o.status AS order_status, o.created_at;

\end{verbatim}
  \begin{table}[h!]
    \centering
    \caption{Data for Processing Task}
    \label{tab:processing_data}
    \begin{tabular}{l l l}
        \toprule
        \textbf{ID} & \textbf{Status} & \textbf{Date} \\
        \midrule
        300000 & Processing & 2024-12-11 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsubsection{Set shipping date or delivered date}
This query sets the shipping date or delivered date for a specific order. This information can be used to track the progress of the order and provide customers with real-time updates on the status of their delivery.
\begin{verbatim}
  MATCH (o:Order ) 
  WHERE o.order_id = "300000"
  RETURN o.shipped_at;
\end{verbatim}
This can be implemented for the delivery date by switching the attribute \textbf{shipped\_at} with \textbf{delivered\_at}.

\subsubsection{Order Status}
This query retrieves the status of the most recent order placed by a specific user. This information can be used by the logistics department to track the progress of the order and provide real-time updates to the user
\begin{verbatim}
  MATCH (u:User)-[:PLACES]->(o:Order)
  WHERE u.id = "100"
  WITH o ORDER BY o.created_at DESC LIMIT 1
  RETURN o.order_id, o.status AS order_status, o.created_at;
\end{verbatim}
\begin{table}[h!]
  \centering
  \caption{Data for Processing Task}
  \label{tab:processing_data}
  \begin{tabular}{l l l}
      \toprule
      \textbf{ID} & \textbf{Status} & \textbf{Timestamp} \\
      \midrule
      561 & Processing & 2023-12-15 17:28:00+00:00 \\
      \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Cross-Sell Opportunity}
This query identifies the top 10 pairs of products that are frequently purchased together in the same order. This information can be used by the logistics department to optimize the packaging and delivery process by grouping frequently purchased items together.
\begin{verbatim}
  MATCH (oi1:OrderItem)-[:REFERS_TO]->(p1:Product),
      (oi2:OrderItem)-[:REFERS_TO]->(p2:Product)
  WHERE oi1.order_id = oi2.order_id AND p1.id < p2.id  
  WITH p1.id AS product1_id, p2.id AS product2_id, oi1.order_id AS order_id
  WITH product1_id, product2_id, COUNT(DISTINCT order_id) AS frequency
  RETURN product1_id, product2_id, frequency
  ORDER BY frequency DESC
  LIMIT 10;
\end{verbatim}

!!!! TODO: ADD TABLE WITH RESULTS

\subsubsection{Average Shipping Time by Country}
This query computes the average shipping time for each country.
In particular it checks if the order has been delivered and created in the same month, and then calculates the difference in days between the two dates.
\begin{verbatim}
  MATCH (u:User)-[:PLACES]->(o:Order)
  WHERE o.delivered_at IS NOT NULL AND o.created_at IS NOT NULL
    AND toInteger(substring(o.delivered_at, 5, 2)) = toInteger(substring(o.created_at, 5, 2))
  WITH u.country AS country, AVG(toInteger(substring(o.delivered_at, 8, 2)) - toInteger(substring(o.created_at, 8, 2))) AS
      avg_shipping_time
  RETURN country, avg_shipping_time
  ORDER BY avg_shipping_time DESC;
\end{verbatim}

\begin{table}[h!]
  \centering
  \caption{Data for Processing Task}
  \label{tab:processing_data}
  \begin{tabular}{l r}
      \toprule
      \textbf{Country} & \textbf{AvgShippingTime} \\
      \midrule
      "Austria" &	6.0\\
      "Colombia" & 4.857142857142857 \\
      "Japan" & 3.9200000000000004 \\
      "France" & 3.845439650464229 \\
      "Spain" & 3.8244325767690226 \\
      "Brasil" & 3.8161648177496104 \\
      "Germany" & 3.8119062697910056 \\
      "Belgium" & 3.805104408352669 \\
      "United States" & 3.797328420082921 \\
      "China" & 3.7945538906214358 \\
      "South Korea" & 3.794032723772863 \\
      "United Kingdom" & 3.7925840092699894 \\
      "Australia" & 3.779141104294479 \\
      "Poland" & 3.670103092783506 \\
      "España" & 2.0 \\
      \bottomrule
  \end{tabular}
\end{table}




\newpage
\section{References \& Sources}
  \begin{thebibliography}{9}
    \bibitem{} Course Slides
    \bibitem{} https://pysimplegui.readthedocs.io/en/latest/call%20reference/
    \bibitem{} https://py2neo.org/
    \bibitem{} https://neo4j.com/docs/cypher-manual/current/
    \bibitem{} https://neo4j.com/developer/python/
    \bibitem{} http://iniball.altervista.org/Software/ProgER
    \bibitem{} https://neo4j.com/developer/cypher/
    \bibitem{} https://pandas.pydata.org/docs/
  \end{thebibliography}
\end{document}